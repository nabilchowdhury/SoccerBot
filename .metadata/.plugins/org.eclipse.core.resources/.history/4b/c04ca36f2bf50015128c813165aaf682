package soccerbot;

import lejos.hardware.Sound;

public class UltrasonicLocalizer {
	// Constants
	private static final int ROTATION_SPD = 400;
	private static final int D_HIGH = 45;
	private static final int D_LOW = 43;
		
	private Odometer odo;
	private Navigation navigate;
	private USPoller usPoller;
	
	public UltrasonicLocalizer(Odometer odometer, Navigation nav, USPoller usPoller){
		this.odo = odometer;
		this.navigate = nav;
		this.usPoller = usPoller;
	}
	
	public void localize(){
		Robonaldo.loadMotor.stop();
		
		double deltaT = 0;
		double angleA, angleB;
		
		Double angleHigh = null; 
		Double angleLow = null;
		
		// Initiate counterclockwise sequence
		navigate.setSpeeds(-ROTATION_SPD, ROTATION_SPD, true);
		
		while(usPoller.getDistance() < D_LOW){
			// empty loop if robot starts facing wall
		}
		
		// Robot is now facing away wall. Use left USSensor for to detect first rising edge
		while(true){
					
			// find angleHigh and angleLow
			if(usPoller.getDistance() <= D_HIGH && angleHigh == null){
				angleHigh = odo.getTheta();
			}else if(usPoller.getDistance() <= D_LOW && angleHigh != null){
				angleLow = odo.getTheta();
			}
					
			// Calculate angleA and break out of loop
			if(angleHigh != null && angleLow != null){
				angleA = (angleHigh+angleLow)/2;
				// reset angleHigh and angleLow
				angleHigh = null;
				angleLow = null;
				
				Sound.beep();
				break;
			}
		}
		
		try{
			Thread.sleep(600);
		}catch(Exception e){}
		
		while(true){
			// Set high and low angles
			if(usPoller.getDistance() >= D_LOW && angleHigh == null){
				angleHigh = odo.getTheta();
			}else if(usPoller.getDistance() >= D_HIGH && angleHigh != null){
				angleLow = odo.getTheta();
			}
			
			// Calculate both angles and break out of loop
			if(angleHigh != null && angleLow != null){
				angleB = (angleHigh+angleLow)/2;		
				angleHigh = null;
				angleLow = null;
				
				Sound.beep();
				break;
				
			}
			
		}
		
		// Correct robot to approximately 0 deg heading
		if(angleA < angleB){
			deltaT = Math.toRadians(45) - (angleA+angleB)/2;
		}else {
			deltaT = Math.toRadians(225) - (angleA+angleB)/2;
		}
						
		// Update odometer angle
		navigate.turnTo(odo.getTheta()+deltaT+Math.PI/2);	
		
	}
	
}
